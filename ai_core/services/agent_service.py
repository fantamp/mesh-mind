"""
Agent Service

Encapsulates the logic for executing AI agents.
"""

import uuid
from ai_core.common.logging import logger
from ai_core.common.adk import run_agent_sync, standard_retry
from ai_core.agents.summarizer.agent import agent as summarizer_agent
from ai_core.agents.qa.agent import agent as qa_agent

@standard_retry
@standard_retry
def run_summarizer(chat_id: str, instruction: str = None, user_id: str = "system", since: str = None, limit: int = None) -> str:
    """
    Runs the Summarizer agent for a specific chat.
    
    Args:
        chat_id: The ID of the chat to summarize.
        instruction: Optional user instruction (e.g., "focus on key decisions").
        user_id: The ID of the user initiating the request.
        since: Optional ISO datetime string to filter messages.
        limit: Optional limit on number of messages to summarize.
        
    Returns:
        The summary text generated by the agent.
    """
    logger.info(f"Running summarizer for chat_id={chat_id}, since={since}, limit={limit}")
    
    base_instruction = f"Please summarize the chat history for chat_id='{chat_id}'."
    
    constraints = []
    if since:
        constraints.append(f"messages sent after {since} (use 'since' parameter)")
    if limit:
        constraints.append(f"only the last {limit} messages (use 'limit' parameter)")
        
    if constraints:
        base_instruction += f" Only consider {' and '.join(constraints)} in fetch_chat_messages."
    
    if instruction:
        user_message = f"{base_instruction}\nUser request: {instruction}"
    else:
        user_message = base_instruction
    
    return run_agent_sync(
        agent=summarizer_agent,
        user_message=user_message,
        user_id=user_id,
        session_id=f"summarizer_{chat_id}_{uuid.uuid4()}"
    )

@standard_retry
def run_document_summarizer(chat_id: str, tags: str = None, user_id: str = "system") -> str:
    """
    Runs the Summarizer agent to summarize documents for a specific chat.
    
    Args:
        chat_id: The ID of the chat to summarize documents for.
        tags: Optional tags to filter documents.
        user_id: The ID of the user initiating the request.
        
    Returns:
        The summary text generated by the agent.
    """
    logger.info(f"Running document summarizer for chat_id={chat_id}, tags={tags}")
    
    user_message = f"Please summarize the documents for chat_id='{chat_id}'"
    if tags:
        user_message += f" with tags='{tags}'"
    user_message += "."
    
    return run_agent_sync(
        agent=summarizer_agent,
        user_message=user_message,
        user_id=user_id,
        session_id=f"doc_summarizer_{chat_id}_{uuid.uuid4()}"
    )

@standard_retry
def run_qa(question: str, chat_id: str = None, user_id: str = "default_user") -> str:
    """
    Runs the QA agent to answer a question.
    
    Args:
        question: The user's question.
        chat_id: Optional chat ID for context.
        user_id: The ID of the user asking the question.
        
    Returns:
        The answer text generated by the agent.
    """
    if not question or not question.strip():
        raise ValueError("Вопрос не может быть пустым")
    
    logger.info(f"Running QA for user={user_id} (chat_id={chat_id}): {question}")
    
    context_prefix = f"CONTEXT: chat_id='{chat_id}'\n" if chat_id else "CONTEXT: chat_id=None\n"
    full_question = context_prefix + "Question: " + question
    
    # Use deterministic session ID for conversation continuity if needed, 
    # or unique if we want stateless. For now, per-user session.
    session_id = f"qa_session_{user_id}"
    
    return run_agent_sync(
        agent=qa_agent,
        user_message=full_question,
        user_id=user_id,
        session_id=session_id
    )
