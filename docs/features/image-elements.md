# Feature: Image Elements Support

## 1. Overview
Добавление поддержки изображений в бота. Бот должен уметь принимать картинки, сохранять их, генерировать текстовое описание с помощью LLM и работать с ними как с элементами типа `image`.

## 2. Problem Statement
В данный момент бот игнорирует отправленные пользователем изображения. Пользователь не может сохранять визуальный контекст или работать с ним через агентов.

## 3. Goals & Value
*   **Value**: Пользователь может сохранять визуальные заметки, скриншоты и фотографии, которые становятся частью базы знаний (Second Brain).
*   **Goal**: Реализовать полный цикл обработки изображения: прием -> сохранение -> описание (LLM) -> создание элемента.

## 4. Proposed Solution (Product Flow)
1.  Пользователь отправляет картинку в чат (как фото или файл).
2.  Бот скачивает изображение во временную директорию.
3.  Бот отправляет изображение в **Gemini Vision** для получения подробного текстового описания.
4.  Формируется имя файла: `<element_id>_<slug>.jpg` (где slug — 1-2 слова из описания).
5.  Файл перемещается в постоянное хранилище `data/images/`.
6.  Создается новый элемент:
    *   **Type**: `image`
    *   **Content**: Текстовое описание от LLM.
    *   **Metadata**: Ссылка на локальный файл изображения.
7.  Элемент попадает в общий пайплайн обработки.

## 5. Technical Design

### 5.1. Storage Strategy
*   **Directory**: `data/images/`.
    *   **Sharding**: Используем шардинг по префиксу `element_id` (первые 2 символа).
    *   *Structure*: `data/images/<ab>/<cd>/<element_id>_<short_slug>.<ext>`
    *   *Example*: Для ID `a1b2c3d4...` путь будет `data/images/a1/b2/a1b2c3d4_cat.jpg`.
*   **Naming Convention**: `<element_id>_<short_slug>.<ext>`
    *   `element_id`: Связь с БД.
    *   `short_slug`: 1-2 слова из краткого описания (транслит или англ), для читаемости при ручном просмотре.
    *   `ext`: Расширение файла (jpg, png, webp).
*   **File Formats**:
    *   Поддерживаем основные форматы: JPEG, PNG, WEBP.
    *   Если приходит нестандартный формат, пытаемся конвертировать в JPEG.

### 5.2. Data Model
*   Новый тип элемента: `image`.
*   Поле `content`: Содержит **только** текстовое описание, сгенерированное LLM.
*   Атрибуты (Attributes):
    *   `file_path`: Путь к файлу (относительный, например `data/images/a1/b2/...`).
    *   `original_filename`: Оригинальное имя файла (обязательно).
    *   `mime_type`: Тип файла (image/jpeg, image/png).

### 5.3. Processing Pipeline (Telegram Layer)
**Architectural Note**: Максимально выносим логику из `handlers.py` в сервисные слои (`ImageService`, `ContentProcessor`). Слой Telegram должен отвечать только за получение input и отправку output.

1.  **Handler**: Ловит `content_type=['photo', 'document']`.
2.  **Validation**: Проверяет MIME-type.
3.  **Service Call**: Передает поток данных (или временный файл) в сервис.
    *   Сервис сохраняет во временный файл.
    *   Сервис вызывает `ImageDescriptionService` (Gemini).
    *   Сервис генерирует ID и путь с шардингом.
    *   Сервис перемещает файл.
    *   Сервис создает элемент через `agent_manager`.
4.  **Feedback**: Handler отправляет пользователю подтверждение (или результат обработки).

### 5.4. Lifecycle & Cleanup
*   **Deletion**: При удалении элемента удалять соответствующий файл.
*   **Garbage Collection**: Скрипт для удаления "сирот" (файлов без элементов).

### 5.5. Testing Strategy
*   **Structure**: Разделение тестов по директориям.
    *   `tests/unit`: Легкие тесты (mocked services, no I/O).
    *   `tests/integration`: Тяжелые тесты (Real API, DB, FS).
*   **Execution**:
    *   `make test`: Запускает только `tests/unit`.
    *   `make heavy-tests`:
        1.  Запускает `make test` (fail fast).
        2.  Если успешно, запускает `pytest tests/integration`.
*   **Heavy Tests Scenario**:
    *   **Scenario**: Реальная обработка тестовой картинки.
    *   **Actions**:
        *   Отправка файла в пайплайн.
        *   **Real API Call**: Вызов реального API Gemini Vision.
        *   Проверка сохранения файла на диске (с шардингом).
        *   Проверка создания записи в БД.

### 5.6. Test Cases Plan
**Light Tests (Unit)**:
1.  `test_mime_validation`: Проверка валидации разрешенных (jpg, png) и запрещенных (exe, txt) форматов.
2.  `test_path_sharding`: Проверка генерации пути (ID `abcdef...` -> `ab/cd/abcdef...`).
3.  `test_slug_generation`: Проверка создания slug из описания ("Кот сидит ... длинный текст .." -> "kot_sidit").
4.  `test_service_orchestration`: Проверка вызова зависимостей (Save -> Describe -> Move -> Create) на моках.
5.  `test_element_creation_logic`: Проверка корректности сборки объекта `Element` (типы полей, метаданные).

**Heavy Tests (Integration)**:
1.  `test_integration_gemini_vision`: Прямой вызов API Gemini с тестовой картинкой, проверка получения непустого описания.
2.  `test_integration_storage_io`: Реальная запись файла, чтение, проверка контрольной суммы (проверка прав доступа и FS).
3.  `test_integration_database_insert`: Вставка `ImageElement` в реальную тестовую БД, выборка и сверка полей.
4.  `test_e2e_full_pipeline`: Полный прогон: отправка файла в Handler -> проверка появления файла на диске и записи в БД.

## 6. Appendix

### LLM Prompt for Image Description (Gemini)

```text
Ты — сервис конвертации изображений в текст для последующей обработки ИИ.

Тебе передают ОДНО изображение. Твоя задача — описать его максимально полезно и подробно так, чтобы с этим текстом потом можно было работать без самой картинки.

Требования к ответу:
1. Пиши на русском языке.
2. Сначала дай КРАТКОЕ резюме (1–2 предложения), затем подробное описание.
3. В подробном описании опиши:
   - общую сцену и контекст (где мы, что примерно происходит);
   - ключевые объекты, людей и их взаимодействия;
   - важные цвета, формы, расположение объектов;
   - любые заметные действия, эмоции, состояние людей;
   - явные факты (что видно точно) и отдельно — осторожные предположения.
4. Если на изображении есть текст (скриншот, документ, интерфейс, плакат и т.п.) — выпиши этот текст отдельно, максимально дословно.
5. Если это скриншот интерфейса или документа — опиши логическую структуру:
   - что за экран/страница;
   - какие есть блоки, кнопки, поля, заголовки, таблицы;
   - какие элементы кажутся важными для понимания смысла.
6. Если чего-то не видно или это неоднозначно — так и пиши, не выдумывай.

Структура ответа:
1) Краткое описание:
<1–2 предложения>

2) Подробное описание:
<несколько абзацев>

3) Текст на изображении (если есть):
- ...

4) Ключевые сущности и теги:
- сущности: ...
- теги: ...
```