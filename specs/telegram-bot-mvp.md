# Спека: Telegram Bot MVP (группы)

## Цель
Обеспечить работу Mesh Mind в групповых чатах Telegram: сохраняем сообщения, реагируем только в оговорённых случаях, вызываем оркестратор для NL‑запросов и команд /ask, /summary.

## Объём (MVP)
- Поддерживаем **только групповые чаты** (no channels/DM).
- Оставляем использование `google.generativeai` (MVP допущение).
- Разрешено упростить или удалить неиспользуемый/legacy код.
- **Оркестратор (ai_core/agents/orchestrator) не изменяем**, используем как есть.

## Функциональные требования
- Бот принимает все сообщения группы и передаёт их в AI Core.
- Реакции (обязательные случаи из docs/requirements/multi-agent-system.md):
  - реплай на сообщение оркестратора;
  - @mention бота;
  - ключевые фразы: «суммаризируй», «что говорили про», «покажи сообщения» (регистр не важен);
  - команды `/ask`, `/summary`.
- На прочие сообщения: сохраняем в БД/векторку, но ответ не отправляем.
- Ответы возвращаются в чат тем же методом (reply, обычное сообщение).
- Все активные реакции (включая `/ask` и `/summary`) проходят через `/api/chat/message` → оркестратор; прямые `/api/ask`/`/api/summarize` держим только для совместимости.
- Голосовые: транскрибируем и отправляем распознанный текст в оркестратор (после сохранения).

## API изменения
- Добавить endpoint `POST /api/chat/message`:
  - Вход: `{ chat_id:str, user_id:str, user_name:str, text:str, message_id:str, reply_to_message_id?:str }`.
  - Поведение (gateway): **сначала** проксирует в `/api/ingest`, сохраняет сообщение/вектор, получает `id`; **затем** вызывает оркестратор (`run_agent_sync(orchestrator)`) с `chat_id` как `session_id`. Возвращает финальный текст ответа или `null`, если оркестратор решил не отвечать.
  - Ответ при отсутствии реакции: HTTP 200 с телом `{ "reply": null }`.
  - Ошибки 4xx/5xx → лог + понятное сообщение боту.
- Оставить существующие `/api/ask`, `/api/summarize` для прямых команд. **Важно**: `/api/summarize` должен вызывать `Chat Summarizer` (агент с доступом к БД), а не `Simple Summarizer` или Оркестратор. `/api/ask` вызывает `QA Agent`.

## Бот (telegram_bot/main.py)
- Всегда инжестировать текст/voice в `/api/ingest` (как сейчас), **дополнительно** отправлять текстовые сообщения в `/api/chat/message`.
- Реагирование:
  - Если `/ask` или `/summary` → вызывать соответствующие команды (можно пока прямые API).
  - Если триггер из списка выше → отправить в `/api/chat/message` и вывести ответ, если не пустой.
  - Иначе — только «Saved.» (без вызова оркестратора).
- Группы: убедиться, что извлекается `author_id`/`author_name`; если `effective_user` отсутствует — подставлять `unknown_<message_id>` чтобы не падать.
- Логирование ошибок с указанием chat_id/message_id.
- Границы компонентов: бот общается только через публичные API (`/ingest`, `/chat/message`, совместимые `/ask`/`/summary`); прямые импорты/вызовы из ai_core запрещены.

## Хранение и tools
- `ai_core.storage.db.Message`: поля автора `author_id`, `author_nick`, `author_name` допускают `null`. Для Telegram сохраняем:
  - Для обычных сообщений: `author_id` = `user.id`, `author_nick` = username без `@`, `author_name` = `first_name last_name`.
  - Для форвардов: брать оригинального автора (`forward_origin.sender_user`/`forward_from`/`forward_sender_name`/`forward_from_chat`), если есть; если нет — fallback на пересылающего. `chat_id` всегда остаётся фактическим чатом, куда сообщение переслали.
  Формат вывода сообщений: 
    - если есть имя и ник: `Имя Фамилия (@username): текст`;
    - если ника нет, но есть id: `Имя Фамилия (id=12345): текст`;
    - если нет имени — используем ник или id, что доступно.
- `ai_core.tools.messages.fetch_messages` добавить параметры `author_id`, `author_nick`, `contains` (substring match), `since`; фильтровать в SQL запросе; вернуть читаемый текст или «No messages found.»; при форматировании аккуратно обходить null.
- Все вызовы `save_message` заполняют доступные поля автора для Telegram; другие источники могут передавать null.
- В VectorDB metadatas при ingest добавлять `author_id`, `author_nick`, `author_name`.
- Во всех вызовах tools/агентов обязательно передавать и фильтровать по `chat_id` (изоляция чатов).

## Агентный слой
- Оркестратор: подтверждённый набор sub‑agents (chat_summarizer, doc_summarizer, qa_agent, chat_observer). Instruction должен явным образом содержать триггеры (реплай на оркестратор, @mention, ключевые фразы «суммаризируй»/«что говорили про»/«покажи сообщения», `/ask`, `/summary`); если нет триггера — возвращать пустой ответ. Агент не модифицируем.
- Chat Observer опирается на обновлённый `fetch_messages` с фильтрами.
- QA агент уже фильтрует по chat_id; оставить.
- Doc summarizer остаётся в составе sub‑agents, даже если в MVP не вызывается напрямую.

### Авто-саммари пересланных сообщений
- Триггер: любая серия пересланных сообщений (ForwardedMessage) из текста или voice; все форварды попадают в пул.
- Дебаунс: если 5 секунд после последнего форварда нет новых форвардов, запускаем саммари по накопленному пулу; новый форвард до истечения таймера перезапускает отсчёт и добавляет сообщение в пул. Лимита нет (MVP).
- **Важно**: При получении первого форварда в серии бот должен отправить сообщение: «Я жду ещё пять секунд доп. сообщения и на это время отключил оркестратора. Если ничего не пришлете, то отправлю присланный пул сообщений в суммаризатор.»
- Поток: форварды сохраняются через `/api/ingest`; **оркестратор НЕ вызывается** пока действует 5-секундное окно ожидания.
- **Смешанный контент**: Если во время 5-секундного окна ожидания пользователь присылает обычное текстовое сообщение (не форвард), оно также **добавляется в пул**, сохраняется, и **оркестратор на него НЕ вызывается** в данном чате.
- По окончании дебаунса бот пишет в чат: «Ну штош... запускаю суммаризацию...», затем вызывает `/api/summarize` напрямую (scope messages) для данного `chat_id` с `since_datetime` = время первого сообщения в пуле и `limit` ≈ размер пула. Саммари отправляется обычным сообщением (не reply). Если саммари пустое/ошибка — отправить «Саммари нет.»
- Для voice используем текст транскрипции из ingest.

## Нефункциональные
- Язык ответов: тот же, что в запросе; сообщения бота — английский UI, комментарии/доки — русский.
- Логи: уровни INFO для успешных вызовов, ERROR для сбоев API/агентов.

## Тестирование (минимум)
- Unit: проверка `fetch_messages` с фильтрами (author_id, contains, since).
- Интеграция (можно ручная чек-лист): 
  1) Сообщение без триггера → сохраняется, нет ответа.
  2) @mention + вопрос → оркестратор отвечает.
  3) Ключевая фраза «суммаризируй» → возвращает саммари.
  4) `/summary 5` → работает.
  5) `/ask <q>` → работает.
