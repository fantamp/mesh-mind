# Спека: Telegram Bot MVP (группы)

## Цель
Обеспечить работу Mesh Mind в групповых чатах Telegram: сохраняем сообщения, реагируем только в оговорённых случаях, вызываем оркестратор для NL‑запросов и команд /ask, /summary.

## Объём (MVP)
- Поддерживаем **только групповые чаты** (no channels/DM).
- Оставляем использование `google.generativeai` (MVP допущение).
- Разрешено упростить или удалить неиспользуемый/legacy код.
- **Оркестратор (ai_core/agents/orchestrator) не изменяем**, используем как есть.

## Функциональные требования
- Бот принимает все сообщения группы и передаёт их в AI Core.
- Реакции (обязательные случаи из docs/requirements/multi-agent-system.md):
  - реплай на сообщение оркестратора;
  - @mention бота;
  - ключевые фразы: «суммаризируй», «что говорили про», «покажи сообщения» (регистр не важен);
  - команды `/ask`, `/summary`.
- На прочие сообщения: сохраняем в БД/векторку, но ответ не отправляем.
- Ответы возвращаются в чат тем же методом (reply, обычное сообщение).
- Все активные реакции (включая `/ask` и `/summary`) проходят через `/api/chat/message` → оркестратор; прямые `/api/ask`/`/api/summarize` держим только для совместимости.

## API изменения
- Добавить endpoint `POST /api/chat/message`:
  - Вход: `{ chat_id:str, user_id:str, user_name:str, text:str, message_id:str, reply_to_message_id?:str }`.
  - Поведение: отправляет текст в **оркестратор** (через `run_agent_sync(orchestrator)`), передавая `chat_id` как `session_id`; возвращает финальный текст ответа или `null`, если оркестратор решил не отвечать.
  - Ошибки 4xx/5xx → лог + понятное сообщение боту.
- Оставить существующие `/api/ask`, `/api/summarize` для прямых команд, но внутренняя логика может быть переведена на оркестратор, если просто.

## Бот (telegram_bot/main.py)
- Всегда инжестировать текст/voice в `/api/ingest` (как сейчас), **дополнительно** отправлять текстовые сообщения в `/api/chat/message`.
- Реагирование:
  - Если `/ask` или `/summary` → вызывать соответствующие команды (можно пока прямые API).
  - Если триггер из списка выше → отправить в `/api/chat/message` и вывести ответ, если не пустой.
  - Иначе — только «Saved.» (без вызова оркестратора).
- Группы: убедиться, что извлекается `author_id`/`author_name`; если `effective_user` отсутствует — подставлять `unknown_<message_id>` чтобы не падать.
- Логирование ошибок с указанием chat_id/message_id.
- Границы компонентов: бот общается только через публичные API (`/ingest`, `/chat/message`, совместимые `/ask`/`/summary`); прямые импорты/вызовы из ai_core запрещены.

## Хранение и tools
- `ai_core.storage.db.Message` добавить `author_id:str` (не nullable); сохранить миграция не нужна (SQLModel recreate для MVP).
- `ai_core.tools.messages.fetch_messages` добавить параметры `author_id`, `contains` (substring match), `since`; фильтровать в SQL запросе; вернуть читаемый текст или «No messages found.»
- Все вызовы `save_message` заполняют `author_id`.
- Во всех вызовах tools/агентов обязательно передавать и фильтровать по `chat_id` (изоляция чатов).

## Агентный слой
- Оркестратор: подтверждённый набор sub‑agents (chat_summarizer, doc_summarizer, qa_agent, chat_observer). Instruction должен соответствовать обязательным случаям реакции; если нет триггера — возвращать пустой ответ. Агент не модифицируем.
- Chat Observer опирается на обновлённый `fetch_messages` с фильтрами.
- QA агент уже фильтрует по chat_id; оставить.
- Doc summarizer остаётся в составе sub‑agents, даже если в MVP не вызывается напрямую.

## Нефункциональные
- Язык ответов: тот же, что в запросе; сообщения бота — английский UI, комментарии/доки — русский.
- Логи: уровни INFO для успешных вызовов, ERROR для сбоев API/агентов.

## Тестирование (минимум)
- Unit: проверка `fetch_messages` с фильтрами (author_id, contains, since).
- Интеграция (можно ручная чек-лист): 
  1) Сообщение без триггера → сохраняется, нет ответа.
  2) @mention + вопрос → оркестратор отвечает.
  3) Ключевая фраза «суммаризируй» → возвращает саммари.
  4) `/summary 5` → работает.
  5) `/ask <q>` → работает.
